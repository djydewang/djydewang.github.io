<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><pre><p><a href="#L1">1</a>/*
</p><p><a href="#L2">2</a> * Copyright 2002-2018 the original author or authors.
</p><p><a href="#L3">3</a> *
</p><p><a href="#L4">4</a> * Licensed under the Apache License, Version 2.0 (the "License");
</p><p><a href="#L5">5</a> * you may not use this file except in compliance with the License.
</p><p><a href="#L6">6</a> * You may obtain a copy of the License at
</p><p><a href="#L7">7</a> *
</p><p><a href="#L8">8</a> *      http://www.apache.org/licenses/LICENSE-2.0
</p><p><a href="#L9">9</a> *
</p><p><a href="#L10">10</a> * Unless required by applicable law or agreed to in writing, software
</p><p><a href="#L11">11</a> * distributed under the License is distributed on an "AS IS" BASIS,
</p><p><a href="#L12">12</a> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</p><p><a href="#L13">13</a> * See the License for the specific language governing permissions and
</p><p><a href="#L14">14</a> * limitations under the License.
</p><p><a href="#L15">15</a> */
</p><p><a href="#L16">16</a>
</p><p><a href="#L17">17</a>package org.springframework.context.support;
</p><p><a href="#L18">18</a>
</p><p><a href="#L19">19</a>import java.util.ArrayList;
</p><p><a href="#L20">20</a>import java.util.Collections;
</p><p><a href="#L21">21</a>import java.util.HashMap;
</p><p><a href="#L22">22</a>import java.util.LinkedHashMap;
</p><p><a href="#L23">23</a>import java.util.LinkedHashSet;
</p><p><a href="#L24">24</a>import java.util.List;
</p><p><a href="#L25">25</a>import java.util.Map;
</p><p><a href="#L26">26</a>import java.util.Set;
</p><p><a href="#L27">27</a>import java.util.concurrent.CountDownLatch;
</p><p><a href="#L28">28</a>import java.util.concurrent.TimeUnit;
</p><p><a href="#L29">29</a>
</p><p><a href="#L30">30</a>import org.apache.commons.logging.Log;
</p><p><a href="#L31">31</a>import org.apache.commons.logging.LogFactory;
</p><p><a href="#L32">32</a>
</p><p><a href="#L33">33</a>import org.springframework.beans.factory.BeanFactory;
</p><p><a href="#L34">34</a>import org.springframework.beans.factory.BeanFactoryAware;
</p><p><a href="#L35">35</a>import org.springframework.beans.factory.BeanFactoryUtils;
</p><p><a href="#L36">36</a>import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
</p><p><a href="#L37">37</a>import org.springframework.context.ApplicationContextException;
</p><p><a href="#L38">38</a>import org.springframework.context.Lifecycle;
</p><p><a href="#L39">39</a>import org.springframework.context.LifecycleProcessor;
</p><p><a href="#L40">40</a>import org.springframework.context.Phased;
</p><p><a href="#L41">41</a>import org.springframework.context.SmartLifecycle;
</p><p><a href="#L42">42</a>import org.springframework.lang.Nullable;
</p><p><a href="#L43">43</a>import org.springframework.util.Assert;
</p><p><a href="#L44">44</a>
</p><p><a href="#L45">45</a>/**
</p><p><a href="#L46">46</a> * Default implementation of the {@link LifecycleProcessor} strategy.
</p><p><a href="#L47">47</a> *
</p><p><a href="#L48">48</a> * @author Mark Fisher
</p><p><a href="#L49">49</a> * @author Juergen Hoeller
</p><p><a href="#L50">50</a> * @since 3.0
</p><p><a href="#L51">51</a> */
</p><p><a href="#L52">52</a>public class DefaultLifecycleProcessor implements LifecycleProcessor, BeanFactoryAware {
</p><p><a href="#L53">53</a>
</p><p><a href="#L54">54</a>	private final Log logger = LogFactory.getLog(getClass());
</p><p><a href="#L55">55</a>
</p><p><a href="#L56">56</a>	private volatile long timeoutPerShutdownPhase = 30000;
</p><p><a href="#L57">57</a>
</p><p><a href="#L58">58</a>	private volatile boolean running;
</p><p><a href="#L59">59</a>
</p><p><a href="#L60">60</a>	@Nullable
</p><p><a href="#L61">61</a>	private volatile ConfigurableListableBeanFactory beanFactory;
</p><p><a href="#L62">62</a>
</p><p><a href="#L63">63</a>
</p><p><a href="#L64">64</a>	/**
</p><p><a href="#L65">65</a>	 * Specify the maximum time allotted in milliseconds for the shutdown of
</p><p><a href="#L66">66</a>	 * any phase (group of SmartLifecycle beans with the same 'phase' value).
</p><p><a href="#L67">67</a>	 * &lt;p&gt;The default value is 30 seconds.
</p><p><a href="#L68">68</a>	 */
</p><p><a href="#L69">69</a>	public void setTimeoutPerShutdownPhase(long timeoutPerShutdownPhase) {
</p><p><a href="#L70">70</a>		this.timeoutPerShutdownPhase = timeoutPerShutdownPhase;
</p><p><a href="#L71">71</a>	}
</p><p><a href="#L72">72</a>
</p><p><a href="#L73">73</a>	@Override
</p><p><a href="#L74">74</a>	public void setBeanFactory(BeanFactory beanFactory) {
</p><p><a href="#L75">75</a>		if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {
</p><p><a href="#L76">76</a>			throw new IllegalArgumentException(
</p><p><a href="#L77">77</a>					"DefaultLifecycleProcessor requires a ConfigurableListableBeanFactory: " + beanFactory);
</p><p><a href="#L78">78</a>		}
</p><p><a href="#L79">79</a>		this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
</p><p><a href="#L80">80</a>	}
</p><p><a href="#L81">81</a>
</p><p><a href="#L82">82</a>	private ConfigurableListableBeanFactory getBeanFactory() {
</p><p><a href="#L83">83</a>		ConfigurableListableBeanFactory beanFactory = this.beanFactory;
</p><p><a href="#L84">84</a>		Assert.state(beanFactory != null, "No BeanFactory available");
</p><p><a href="#L85">85</a>		return beanFactory;
</p><p><a href="#L86">86</a>	}
</p><p><a href="#L87">87</a>
</p><p><a href="#L88">88</a>
</p><p><a href="#L89">89</a>	// Lifecycle implementation
</p><p><a href="#L90">90</a>
</p><p><a href="#L91">91</a>	/**
</p><p><a href="#L92">92</a>	 * Start all registered beans that implement {@link Lifecycle} and are &lt;i&gt;not&lt;/i&gt;
</p><p><a href="#L93">93</a>	 * already running. Any bean that implements {@link SmartLifecycle} will be
</p><p><a href="#L94">94</a>	 * started within its 'phase', and all phases will be ordered from lowest to
</p><p><a href="#L95">95</a>	 * highest value. All beans that do not implement {@link SmartLifecycle} will be
</p><p><a href="#L96">96</a>	 * started in the default phase 0. A bean declared as a dependency of another bean
</p><p><a href="#L97">97</a>	 * will be started before the dependent bean regardless of the declared phase.
</p><p><a href="#L98">98</a>	 */
</p><p><a href="#L99">99</a>	@Override
</p><p><a href="#L100">100</a>	public void start() {
</p><p><a href="#L101">101</a>		startBeans(false);
</p><p><a href="#L102">102</a>		this.running = true;
</p><p><a href="#L103">103</a>	}
</p><p><a href="#L104">104</a>
</p><p><a href="#L105">105</a>	/**
</p><p><a href="#L106">106</a>	 * Stop all registered beans that implement {@link Lifecycle} and &lt;i&gt;are&lt;/i&gt;
</p><p><a href="#L107">107</a>	 * currently running. Any bean that implements {@link SmartLifecycle} will be
</p><p><a href="#L108">108</a>	 * stopped within its 'phase', and all phases will be ordered from highest to
</p><p><a href="#L109">109</a>	 * lowest value. All beans that do not implement {@link SmartLifecycle} will be
</p><p><a href="#L110">110</a>	 * stopped in the default phase 0. A bean declared as dependent on another bean
</p><p><a href="#L111">111</a>	 * will be stopped before the dependency bean regardless of the declared phase.
</p><p><a href="#L112">112</a>	 */
</p><p><a href="#L113">113</a>	@Override
</p><p><a href="#L114">114</a>	public void stop() {
</p><p><a href="#L115">115</a>		stopBeans();
</p><p><a href="#L116">116</a>		this.running = false;
</p><p><a href="#L117">117</a>	}
</p><p><a href="#L118">118</a>
</p><p><a href="#L119">119</a>	@Override
</p><p><a href="#L120">120</a>	public void onRefresh() {
</p><p><a href="#L121">121</a>		startBeans(true);
</p><p><a href="#L122">122</a>		this.running = true;
</p><p><a href="#L123">123</a>	}
</p><p><a href="#L124">124</a>
</p><p><a href="#L125">125</a>	@Override
</p><p><a href="#L126">126</a>	public void onClose() {
</p><p><a href="#L127">127</a>		stopBeans();
</p><p><a href="#L128">128</a>		this.running = false;
</p><p><a href="#L129">129</a>	}
</p><p><a href="#L130">130</a>
</p><p><a href="#L131">131</a>	@Override
</p><p><a href="#L132">132</a>	public boolean isRunning() {
</p><p><a href="#L133">133</a>		return this.running;
</p><p><a href="#L134">134</a>	}
</p><p><a href="#L135">135</a>
</p><p><a href="#L136">136</a>
</p><p><a href="#L137">137</a>	// Internal helpers
</p><p><a href="#L138">138</a>
</p><p><a href="#L139">139</a>	private void startBeans(boolean autoStartupOnly) {
</p><p><a href="#L140">140</a>		Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();
</p><p><a href="#L141">141</a>		Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;&gt;();
</p><p><a href="#L142">142</a>		lifecycleBeans.forEach((beanName, bean) -&gt; {
</p><p><a href="#L143">143</a>			if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) {
</p><p><a href="#L144">144</a>				int phase = getPhase(bean);
</p><p><a href="#L145">145</a>				LifecycleGroup group = phases.get(phase);
</p><p><a href="#L146">146</a>				if (group == null) {
</p><p><a href="#L147">147</a>					group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
</p><p><a href="#L148">148</a>					phases.put(phase, group);
</p><p><a href="#L149">149</a>				}
</p><p><a href="#L150">150</a>				group.add(beanName, bean);
</p><p><a href="#L151">151</a>			}
</p><p><a href="#L152">152</a>		});
</p><p><a href="#L153">153</a>		if (!phases.isEmpty()) {
</p><p><a href="#L154">154</a>			List&lt;Integer&gt; keys = new ArrayList&lt;&gt;(phases.keySet());
</p><p><a href="#L155">155</a>			Collections.sort(keys);
</p><p><a href="#L156">156</a>			for (Integer key : keys) {
</p><p><a href="#L157">157</a>				phases.get(key).start();
</p><p><a href="#L158">158</a>			}
</p><p><a href="#L159">159</a>		}
</p><p><a href="#L160">160</a>	}
</p><p><a href="#L161">161</a>
</p><p><a href="#L162">162</a>	/**
</p><p><a href="#L163">163</a>	 * Start the specified bean as part of the given set of Lifecycle beans,
</p><p><a href="#L164">164</a>	 * making sure that any beans that it depends on are started first.
</p><p><a href="#L165">165</a>	 * @param lifecycleBeans Map with bean name as key and Lifecycle instance as value
</p><p><a href="#L166">166</a>	 * @param beanName the name of the bean to start
</p><p><a href="#L167">167</a>	 */
</p><p><a href="#L168">168</a>	private void doStart(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, String beanName, boolean autoStartupOnly) {
</p><p><a href="#L169">169</a>		Lifecycle bean = lifecycleBeans.remove(beanName);
</p><p><a href="#L170">170</a>		if (bean != null &amp;&amp; !this.equals(bean)) {
</p><p><a href="#L171">171</a>			String[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);
</p><p><a href="#L172">172</a>			for (String dependency : dependenciesForBean) {
</p><p><a href="#L173">173</a>				doStart(lifecycleBeans, dependency, autoStartupOnly);
</p><p><a href="#L174">174</a>			}
</p><p><a href="#L175">175</a>			if (!bean.isRunning() &amp;&amp;
</p><p><a href="#L176">176</a>					(!autoStartupOnly || !(bean instanceof SmartLifecycle) || ((SmartLifecycle) bean).isAutoStartup())) {
</p><p><a href="#L177">177</a>				if (logger.isDebugEnabled()) {
</p><p><a href="#L178">178</a>					logger.debug("Starting bean '" + beanName + "' of type [" + bean.getClass() + "]");
</p><p><a href="#L179">179</a>				}
</p><p><a href="#L180">180</a>				try {
</p><p><a href="#L181">181</a>					bean.start();
</p><p><a href="#L182">182</a>				}
</p><p><a href="#L183">183</a>				catch (Throwable ex) {
</p><p><a href="#L184">184</a>					throw new ApplicationContextException("Failed to start bean '" + beanName + "'", ex);
</p><p><a href="#L185">185</a>				}
</p><p><a href="#L186">186</a>				if (logger.isDebugEnabled()) {
</p><p><a href="#L187">187</a>					logger.debug("Successfully started bean '" + beanName + "'");
</p><p><a href="#L188">188</a>				}
</p><p><a href="#L189">189</a>			}
</p><p><a href="#L190">190</a>		}
</p><p><a href="#L191">191</a>	}
</p><p><a href="#L192">192</a>
</p><p><a href="#L193">193</a>	private void stopBeans() {
</p><p><a href="#L194">194</a>		Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();
</p><p><a href="#L195">195</a>		Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;&gt;();
</p><p><a href="#L196">196</a>		lifecycleBeans.forEach((beanName, bean) -&gt; {
</p><p><a href="#L197">197</a>			int shutdownOrder = getPhase(bean);
</p><p><a href="#L198">198</a>			LifecycleGroup group = phases.get(shutdownOrder);
</p><p><a href="#L199">199</a>			if (group == null) {
</p><p><a href="#L200">200</a>				group = new LifecycleGroup(shutdownOrder, this.timeoutPerShutdownPhase, lifecycleBeans, false);
</p><p><a href="#L201">201</a>				phases.put(shutdownOrder, group);
</p><p><a href="#L202">202</a>			}
</p><p><a href="#L203">203</a>			group.add(beanName, bean);
</p><p><a href="#L204">204</a>		});
</p><p><a href="#L205">205</a>		if (!phases.isEmpty()) {
</p><p><a href="#L206">206</a>			List&lt;Integer&gt; keys = new ArrayList&lt;&gt;(phases.keySet());
</p><p><a href="#L207">207</a>			keys.sort(Collections.reverseOrder());
</p><p><a href="#L208">208</a>			for (Integer key : keys) {
</p><p><a href="#L209">209</a>				phases.get(key).stop();
</p><p><a href="#L210">210</a>			}
</p><p><a href="#L211">211</a>		}
</p><p><a href="#L212">212</a>	}
</p><p><a href="#L213">213</a>
</p><p><a href="#L214">214</a>	/**
</p><p><a href="#L215">215</a>	 * Stop the specified bean as part of the given set of Lifecycle beans,
</p><p><a href="#L216">216</a>	 * making sure that any beans that depends on it are stopped first.
</p><p><a href="#L217">217</a>	 * @param lifecycleBeans Map with bean name as key and Lifecycle instance as value
</p><p><a href="#L218">218</a>	 * @param beanName the name of the bean to stop
</p><p><a href="#L219">219</a>	 */
</p><p><a href="#L220">220</a>	private void doStop(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, final String beanName,
</p><p><a href="#L221">221</a>			final CountDownLatch latch, final Set&lt;String&gt; countDownBeanNames) {
</p><p><a href="#L222">222</a>
</p><p><a href="#L223">223</a>		Lifecycle bean = lifecycleBeans.remove(beanName);
</p><p><a href="#L224">224</a>		if (bean != null) {
</p><p><a href="#L225">225</a>			String[] dependentBeans = getBeanFactory().getDependentBeans(beanName);
</p><p><a href="#L226">226</a>			for (String dependentBean : dependentBeans) {
</p><p><a href="#L227">227</a>				doStop(lifecycleBeans, dependentBean, latch, countDownBeanNames);
</p><p><a href="#L228">228</a>			}
</p><p><a href="#L229">229</a>			try {
</p><p><a href="#L230">230</a>				if (bean.isRunning()) {
</p><p><a href="#L231">231</a>					if (bean instanceof SmartLifecycle) {
</p><p><a href="#L232">232</a>						if (logger.isDebugEnabled()) {
</p><p><a href="#L233">233</a>							logger.debug("Asking bean '" + beanName + "' of type [" + bean.getClass() + "] to stop");
</p><p><a href="#L234">234</a>						}
</p><p><a href="#L235">235</a>						countDownBeanNames.add(beanName);
</p><p><a href="#L236">236</a>						((SmartLifecycle) bean).stop(() -&gt; {
</p><p><a href="#L237">237</a>							latch.countDown();
</p><p><a href="#L238">238</a>							countDownBeanNames.remove(beanName);
</p><p><a href="#L239">239</a>							if (logger.isDebugEnabled()) {
</p><p><a href="#L240">240</a>								logger.debug("Bean '" + beanName + "' completed its stop procedure");
</p><p><a href="#L241">241</a>							}
</p><p><a href="#L242">242</a>						});
</p><p><a href="#L243">243</a>					}
</p><p><a href="#L244">244</a>					else {
</p><p><a href="#L245">245</a>						if (logger.isDebugEnabled()) {
</p><p><a href="#L246">246</a>							logger.debug("Stopping bean '" + beanName + "' of type [" + bean.getClass() + "]");
</p><p><a href="#L247">247</a>						}
</p><p><a href="#L248">248</a>						bean.stop();
</p><p><a href="#L249">249</a>						if (logger.isDebugEnabled()) {
</p><p><a href="#L250">250</a>							logger.debug("Successfully stopped bean '" + beanName + "'");
</p><p><a href="#L251">251</a>						}
</p><p><a href="#L252">252</a>					}
</p><p><a href="#L253">253</a>				}
</p><p><a href="#L254">254</a>				else if (bean instanceof SmartLifecycle) {
</p><p><a href="#L255">255</a>					// don't wait for beans that aren't running
</p><p><a href="#L256">256</a>					latch.countDown();
</p><p><a href="#L257">257</a>				}
</p><p><a href="#L258">258</a>			}
</p><p><a href="#L259">259</a>			catch (Throwable ex) {
</p><p><a href="#L260">260</a>				if (logger.isWarnEnabled()) {
</p><p><a href="#L261">261</a>					logger.warn("Failed to stop bean '" + beanName + "'", ex);
</p><p><a href="#L262">262</a>				}
</p><p><a href="#L263">263</a>			}
</p><p><a href="#L264">264</a>		}
</p><p><a href="#L265">265</a>	}
</p><p><a href="#L266">266</a>
</p><p><a href="#L267">267</a>
</p><p><a href="#L268">268</a>	// overridable hooks
</p><p><a href="#L269">269</a>
</p><p><a href="#L270">270</a>	/**
</p><p><a href="#L271">271</a>	 * Retrieve all applicable Lifecycle beans: all singletons that have already been created,
</p><p><a href="#L272">272</a>	 * as well as all SmartLifecycle beans (even if they are marked as lazy-init).
</p><p><a href="#L273">273</a>	 * @return the Map of applicable beans, with bean names as keys and bean instances as values
</p><p><a href="#L274">274</a>	 */
</p><p><a href="#L275">275</a>	protected Map&lt;String, Lifecycle&gt; getLifecycleBeans() {
</p><p><a href="#L276">276</a>		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
</p><p><a href="#L277">277</a>		Map&lt;String, Lifecycle&gt; beans = new LinkedHashMap&lt;&gt;();
</p><p><a href="#L278">278</a>		String[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, false, false);
</p><p><a href="#L279">279</a>		for (String beanName : beanNames) {
</p><p><a href="#L280">280</a>			String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);
</p><p><a href="#L281">281</a>			boolean isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);
</p><p><a href="#L282">282</a>			String beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);
</p><p><a href="#L283">283</a>			if ((beanFactory.containsSingleton(beanNameToRegister) &amp;&amp;
</p><p><a href="#L284">284</a>					(!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) ||
</p><p><a href="#L285">285</a>					matchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) {
</p><p><a href="#L286">286</a>				Object bean = beanFactory.getBean(beanNameToCheck);
</p><p><a href="#L287">287</a>				if (bean != this &amp;&amp; bean instanceof Lifecycle) {
</p><p><a href="#L288">288</a>					beans.put(beanNameToRegister, (Lifecycle) bean);
</p><p><a href="#L289">289</a>				}
</p><p><a href="#L290">290</a>			}
</p><p><a href="#L291">291</a>		}
</p><p><a href="#L292">292</a>		return beans;
</p><p><a href="#L293">293</a>	}
</p><p><a href="#L294">294</a>
</p><p><a href="#L295">295</a>	private boolean matchesBeanType(Class&lt;?&gt; targetType, String beanName, BeanFactory beanFactory) {
</p><p><a href="#L296">296</a>		Class&lt;?&gt; beanType = beanFactory.getType(beanName);
</p><p><a href="#L297">297</a>		return (beanType != null &amp;&amp; targetType.isAssignableFrom(beanType));
</p><p><a href="#L298">298</a>	}
</p><p><a href="#L299">299</a>
</p><p><a href="#L300">300</a>	/**
</p><p><a href="#L301">301</a>	 * Determine the lifecycle phase of the given bean.
</p><p><a href="#L302">302</a>	 * &lt;p&gt;The default implementation checks for the {@link Phased} interface.
</p><p><a href="#L303">303</a>	 * Can be overridden to apply other/further policies.
</p><p><a href="#L304">304</a>	 * @param bean the bean to introspect
</p><p><a href="#L305">305</a>	 * @return the phase an integer value. The suggested default is 0.
</p><p><a href="#L306">306</a>	 * @see Phased
</p><p><a href="#L307">307</a>	 * @see SmartLifecycle
</p><p><a href="#L308">308</a>	 */
</p><p><a href="#L309">309</a>	protected int getPhase(Lifecycle bean) {
</p><p><a href="#L310">310</a>		return (bean instanceof Phased ? ((Phased) bean).getPhase() : 0);
</p><p><a href="#L311">311</a>	}
</p><p><a href="#L312">312</a>
</p><p><a href="#L313">313</a>
</p><p><a href="#L314">314</a>	/**
</p><p><a href="#L315">315</a>	 * Helper class for maintaining a group of Lifecycle beans that should be started
</p><p><a href="#L316">316</a>	 * and stopped together based on their 'phase' value (or the default value of 0).
</p><p><a href="#L317">317</a>	 */
</p><p><a href="#L318">318</a>	private class LifecycleGroup {
</p><p><a href="#L319">319</a>
</p><p><a href="#L320">320</a>		private final List&lt;LifecycleGroupMember&gt; members = new ArrayList&lt;&gt;();
</p><p><a href="#L321">321</a>
</p><p><a href="#L322">322</a>		private final int phase;
</p><p><a href="#L323">323</a>
</p><p><a href="#L324">324</a>		private final long timeout;
</p><p><a href="#L325">325</a>
</p><p><a href="#L326">326</a>		private final Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans;
</p><p><a href="#L327">327</a>
</p><p><a href="#L328">328</a>		private final boolean autoStartupOnly;
</p><p><a href="#L329">329</a>
</p><p><a href="#L330">330</a>		private volatile int smartMemberCount;
</p><p><a href="#L331">331</a>
</p><p><a href="#L332">332</a>		public LifecycleGroup(int phase, long timeout, Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, boolean autoStartupOnly) {
</p><p><a href="#L333">333</a>			this.phase = phase;
</p><p><a href="#L334">334</a>			this.timeout = timeout;
</p><p><a href="#L335">335</a>			this.lifecycleBeans = lifecycleBeans;
</p><p><a href="#L336">336</a>			this.autoStartupOnly = autoStartupOnly;
</p><p><a href="#L337">337</a>		}
</p><p><a href="#L338">338</a>
</p><p><a href="#L339">339</a>		public void add(String name, Lifecycle bean) {
</p><p><a href="#L340">340</a>			if (bean instanceof SmartLifecycle) {
</p><p><a href="#L341">341</a>				this.smartMemberCount++;
</p><p><a href="#L342">342</a>			}
</p><p><a href="#L343">343</a>			this.members.add(new LifecycleGroupMember(name, bean));
</p><p><a href="#L344">344</a>		}
</p><p><a href="#L345">345</a>
</p><p><a href="#L346">346</a>		public void start() {
</p><p><a href="#L347">347</a>			if (this.members.isEmpty()) {
</p><p><a href="#L348">348</a>				return;
</p><p><a href="#L349">349</a>			}
</p><p><a href="#L350">350</a>			if (logger.isInfoEnabled()) {
</p><p><a href="#L351">351</a>				logger.info("Starting beans in phase " + this.phase);
</p><p><a href="#L352">352</a>			}
</p><p><a href="#L353">353</a>			Collections.sort(this.members);
</p><p><a href="#L354">354</a>			for (LifecycleGroupMember member : this.members) {
</p><p><a href="#L355">355</a>				if (this.lifecycleBeans.containsKey(member.name)) {
</p><p><a href="#L356">356</a>					doStart(this.lifecycleBeans, member.name, this.autoStartupOnly);
</p><p><a href="#L357">357</a>				}
</p><p><a href="#L358">358</a>			}
</p><p><a href="#L359">359</a>		}
</p><p><a href="#L360">360</a>
</p><p><a href="#L361">361</a>		public void stop() {
</p><p><a href="#L362">362</a>			if (this.members.isEmpty()) {
</p><p><a href="#L363">363</a>				return;
</p><p><a href="#L364">364</a>			}
</p><p><a href="#L365">365</a>			if (logger.isInfoEnabled()) {
</p><p><a href="#L366">366</a>				logger.info("Stopping beans in phase " + this.phase);
</p><p><a href="#L367">367</a>			}
</p><p><a href="#L368">368</a>			this.members.sort(Collections.reverseOrder());
</p><p><a href="#L369">369</a>			CountDownLatch latch = new CountDownLatch(this.smartMemberCount);
</p><p><a href="#L370">370</a>			Set&lt;String&gt; countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;());
</p><p><a href="#L371">371</a>			for (LifecycleGroupMember member : this.members) {
</p><p><a href="#L372">372</a>				if (this.lifecycleBeans.containsKey(member.name)) {
</p><p><a href="#L373">373</a>					doStop(this.lifecycleBeans, member.name, latch, countDownBeanNames);
</p><p><a href="#L374">374</a>				}
</p><p><a href="#L375">375</a>				else if (member.bean instanceof SmartLifecycle) {
</p><p><a href="#L376">376</a>					// already removed, must have been a dependent
</p><p><a href="#L377">377</a>					latch.countDown();
</p><p><a href="#L378">378</a>				}
</p><p><a href="#L379">379</a>			}
</p><p><a href="#L380">380</a>			try {
</p><p><a href="#L381">381</a>				latch.await(this.timeout, TimeUnit.MILLISECONDS);
</p><p><a href="#L382">382</a>				if (latch.getCount() &gt; 0 &amp;&amp; !countDownBeanNames.isEmpty() &amp;&amp; logger.isWarnEnabled()) {
</p><p><a href="#L383">383</a>					logger.warn("Failed to shut down " + countDownBeanNames.size() + " bean" +
</p><p><a href="#L384">384</a>							(countDownBeanNames.size() &gt; 1 ? "s" : "") + " with phase value " +
</p><p><a href="#L385">385</a>							this.phase + " within timeout of " + this.timeout + ": " + countDownBeanNames);
</p><p><a href="#L386">386</a>				}
</p><p><a href="#L387">387</a>			}
</p><p><a href="#L388">388</a>			catch (InterruptedException ex) {
</p><p><a href="#L389">389</a>				Thread.currentThread().interrupt();
</p><p><a href="#L390">390</a>			}
</p><p><a href="#L391">391</a>		}
</p><p><a href="#L392">392</a>	}
</p><p><a href="#L393">393</a>
</p><p><a href="#L394">394</a>
</p><p><a href="#L395">395</a>	/**
</p><p><a href="#L396">396</a>	 * Adapts the Comparable interface onto the lifecycle phase model.
</p><p><a href="#L397">397</a>	 */
</p><p><a href="#L398">398</a>	private class LifecycleGroupMember implements Comparable&lt;LifecycleGroupMember&gt; {
</p><p><a href="#L399">399</a>
</p><p><a href="#L400">400</a>		private final String name;
</p><p><a href="#L401">401</a>
</p><p><a href="#L402">402</a>		private final Lifecycle bean;
</p><p><a href="#L403">403</a>
</p><p><a href="#L404">404</a>		LifecycleGroupMember(String name, Lifecycle bean) {
</p><p><a href="#L405">405</a>			this.name = name;
</p><p><a href="#L406">406</a>			this.bean = bean;
</p><p><a href="#L407">407</a>		}
</p><p><a href="#L408">408</a>
</p><p><a href="#L409">409</a>		@Override
</p><p><a href="#L410">410</a>		public int compareTo(LifecycleGroupMember other) {
</p><p><a href="#L411">411</a>			int thisOrder = getPhase(this.bean);
</p><p><a href="#L412">412</a>			int otherOrder = getPhase(other.bean);
</p><p><a href="#L413">413</a>			return Integer.compare(thisOrder, otherOrder);
</p><p><a href="#L414">414</a>		}
</p><p><a href="#L415">415</a>	}
</p><p><a href="#L416">416</a>
</p><p><a href="#L417">417</a>}
</p></pre></body></html>
